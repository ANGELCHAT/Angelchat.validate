// Generated by CoffeeScript 1.9.2
var Validator, _, _regexp,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('underscore');

_regexp = {
  ruleName: /%s/g,
  ruleKey: /%([a-zA-Z]{1}([a-zA-Z0-9\-_]{1,})?)/g
};

Validator = {
  options: {
    errorParser: null
  },
  rules: {},
  addRule: function(name, rule) {
    return this.rules[name] = rule;
  },
  checkRule: function(name) {
    var rule;
    rule = this.rules[name];
    switch (rule.recurrent) {
      case true:
        if (typeof name === 'string' && rule && typeof rule.test === 'function' && rule.ruleset) {
          return true;
        }
        break;
      default:
        if (typeof name === 'string' && rule && typeof rule.test === 'function' && typeof rule.message === 'string') {
          return true;
        }
    }
    throw new Error(name + ' is not a complete rule. A complete rule must contain both `test` function and `message` string.');
  },
  error: function(rule, key, message, ruleArgs) {
    if (!message) {
      message = this.rules[rule].message;
    }
    return message.replace(_regexp.ruleName, key).replace(_regexp.ruleKey, (function(_this) {
      return function(whole, first) {
        if (ruleArgs[first] != null) {
          return ruleArgs[first];
        } else if (_this.rules[rule][first] != null) {
          return _this.rules[rule][first];
        }
        return whole;
      };
    })(this));
  },
  testInternal: function(obj, rule, key) {
    var context, err, error, message, theRule;
    theRule = rule;
    if (typeof rule !== 'string') {
      theRule = rule.rule;
    }
    if (this.checkRule(theRule)) {
      if (this.rules[theRule].recurrent == null) {
        this.rules[theRule].recurrent = false;
      }
      context = _.defaults(this.rules[theRule], this);
      if (theRule === 'required' || (obj[key] != null)) {
        error = this.rules[theRule].test.call(context, obj[key], rule);
        if (this.rules[theRule].recurrent) {
          if (error.length) {
            message = this.error(theRule, key, rule.message, rule);
            err = {};
            err[message] = error;
            return err;
          }
        } else if (error === false) {
          return this.error(theRule, key, rule.message, rule);
        }
      }
    }
    return false;
  },
  validate: function(obj, ruleset) {
    var e, errors, i, key, len1, nestedRule, rule, testResult;
    errors = [];
    if (_.isString(ruleset)) {
      try {
        ruleset = this.rules[ruleset].ruleset;
      } catch (_error) {
        e = _error;
        throw new Error("missing " + ruleset + " validation rule");
      }
    }
    for (key in ruleset) {
      rule = ruleset[key];
      if (Array.isArray(rule)) {
        for (i = 0, len1 = rule.length; i < len1; i++) {
          nestedRule = rule[i];
          testResult = this.testInternal(obj, nestedRule, key);
          if (testResult) {
            errors.push(testResult);
          }
        }
      } else {
        testResult = this.testInternal(obj, rule, key);
        if (testResult) {
          errors.push(testResult);
        }
      }
    }
    if (errors.length) {
      return errors;
    }
    return [];
  }
};

Validator.addRule('required', {
  message: "%s is required",
  test: function(str) {
    return str != null;
  }
});

Validator.addRule('email', {
  message: "%s must be a valid e-mail address",
  regex: /^([\w\!\#$\%\&\'\*\+\-\/\=\?\^\`{\|\}\~]+\.)*[\w\!\#$\%\&\'\*\+\-\/\=\?\^\`{\|\}\~]+@((((([a-z0-9]{1}[a-z0-9\-]{0,62}[a-z0-9]{1})|[a-z0-9])\.)+[a-z]{2,32})|(\d{1,3}\.){3}\d{1,3}(\:\d{1,5})?)$/i,
  test: function(str) {
    return this.regex.test(str);
  }
});

Validator.addRule('lengthBetween', {
  message: "%s must be between %low and %high characters long",
  low: 0,
  high: 5,
  test: function(str, rule) {
    var high, len, low;
    if (typeof str !== 'string') {
      return false;
    }
    low = rule.low || this.low;
    high = rule.high || this.high;
    len = str.length;
    return (low <= len && len <= high);
  }
});

Validator.addRule('minLength', {
  message: "%s must be at least %minLength characters long",
  minLength: 1,
  test: function(str, rule) {
    var minLength;
    minLength = (rule != null ? rule.minLength : void 0) || this.minLength;
    return this.rules.lengthBetween.test(str, {
      low: minLength,
      high: Infinity
    });
  }
});

Validator.addRule('maxLength', {
  message: "%s must be at most %maxLength characters long",
  maxLength: 1,
  test: function(str, rule) {
    var maxLength;
    maxLength = (rule != null ? rule.maxLength : void 0) || this.maxLength;
    return this.rules.lengthBetween.test(str, {
      low: 0,
      high: maxLength
    });
  }
});

Validator.addRule('between', {
  message: "%s must be between %low and %high",
  low: 0,
  high: 0,
  test: function(str, rule) {
    var high, low;
    str = parseInt(str, 10);
    low = rule.low || this.low;
    high = rule.high || this.high;
    return (low <= str && str <= high);
  }
});

Validator.addRule('greaterThan', {
  message: "%s must be greater than %than",
  than: 0,
  test: function(str, rule) {
    var than;
    than = rule.than || this.than;
    return this.rules.between.test(str, {
      low: than + 1,
      high: Infinity
    });
  }
});

Validator.addRule('lowerThan', {
  message: "%s must be lower than %than",
  than: 0,
  test: function(str, rule) {
    var than;
    than = rule.than || this.than;
    return this.rules.between.test(str, {
      low: -Infinity,
      high: than - 1
    });
  }
});

Validator.addRule('nonNegative', {
  message: "%s must be non-negative",
  test: function(str) {
    return this.rules.between.test(str, {
      low: -1,
      high: Infinity
    });
  }
});

Validator.addRule('positive', {
  message: "%s must be positive",
  test: function(str) {
    return this.rules.between.test(str, {
      low: 1,
      high: Infinity
    });
  }
});

Validator.addRule('negative', {
  message: "%s must be negative",
  test: function(str) {
    return this.rules.between.test(str, {
      low: -Infinity,
      high: -1
    });
  }
});

Validator.addRule('integer', {
  message: "%s must be an integer",
  test: function(str) {
    return /^-?[0-9]+$/.test(str);
  }
});

Validator.addRule('match', {
  message: "%s doesn't match the required pattern",
  pattern: /(.)*/,
  test: function(str, rule) {
    var pattern;
    pattern = rule.pattern || this.pattern;
    return str.match(pattern);
  }
});

Validator.addRule('equals', {
  message: "%s isn't '%to'",
  to: "",
  test: function(str, rule) {
    var to;
    to = rule.to || this.to;
    return str === to;
  }
});

Validator.addRule('list', {
  recurrent: true,
  message: "invalid %s list",
  ruleset: 'required',
  test: function(array, rule) {
    var e, element, error, errors, i, index, len1, ruleset;
    errors = [];
    ruleset = rule.ruleset || this.ruleset;
    for (index = i = 0, len1 = array.length; i < len1; index = ++i) {
      element = array[index];
      error = this.validate({
        element: element
      }, {
        element: ruleset
      });
      if (error.length) {
        e = {};
        e[index] = error;
        errors.push(e);
      }
    }
    return errors;
  }
});

Validator.addRule('notEmpty', {
  message: "%s can't be empty array",
  test: function(obj) {
    return !_.isEmpty(obj);
  }
});

Validator.addRule('array', {
  message: "%s must be an array",
  test: function(obj) {
    return _.isArray(obj);
  }
});

Validator.addRule('binary', {
  message: "%s must be either '0' or '1'",
  test: function(str) {
    var ref;
    if (str == null) {
      return false;
    }
    return (ref = str.toString()) === '0' || ref === '1';
  }
});

Validator.addRule('order', {
  order: ['asc', 'desc'],
  message: "%s must be either 'asc' or 'desc'",
  test: function(order) {
    return indexOf.call(this.order, order) >= 0;
  }
});

Validator.addRule('zipcode', {
  message: "%s must be valid zip code format XX-XXX",
  test: function(code) {
    return /(^\d{3}-\d{2}$)/.test(code);
  }
});

Validator.addRule('deny', {
  message: "%s is forbidden",
  test: function() {
    return false;
  }
});

module.exports = Validator;
